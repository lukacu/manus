{"language":"python","name":"Sorting blocks","timestamp":"2017-12-20T22:48:30.863Z","code":"import numpy as np\nimport scipy.spatial.distance\nimport math\nfrom random import shuffle\nimport traceback\n\nfrom math import *\n\ndef evaluate_block(workspace, blocks, active, groups):\n\n    block = blocks[active]\n\n    group = block_color_name(block)\n\n    if not group in groups:\n        return False\n\n    r = groups[group][\"region\"]\n    p = block.position\n    if (p[0] > r[0]) and (p[1] > r[1]) and (p[0] < r[0] + r[2]) and (p[1] < r[1] + r[3]):\n        return False\n\n    padding = 20\n    targets = np.concatenate((np.random.uniform(r[0] + padding, r[0] + r[2] - padding, (100,1)),  np.random.uniform(r[1] + padding, r[1] + r[3] - padding, (100,1))), axis=1)\n    obstacles = np.array([b.position[0:2] for b in blocks], dtype='float32')\n    D = scipy.spatial.distance.cdist(targets, obstacles, 'euclidean')\n    targets = targets[np.all(D > 50, 1)]\n    target = None\n\n    if len(targets) < 1:\n        return False\n\n    print \"Attempting to move %s box ... \" % group,\n    t = targets[0]\n    angle1 = block.rotation[2] - math.pi / 2\n    angle2 = atan2(t[1], t[0])\n\n    trajectory = [\n        manus.MoveTo((p[0], p[1], 120.0), (0.0, 0.0, angle1), 0.0),\n        manus.MoveTo((p[0], p[1], 20.0), (0.0, 0.0, angle1), 0.0),\n        manus.MoveTo((p[0], p[1], 20.0), (0.0, 0.0, angle1), 0.8),\n        manus.MoveTo((p[0], p[1], 120.0), (0.0, 0.0, angle1), 0.8),\n        manus.MoveTo((t[0], t[1], 120.0), (0.0, 0.0, angle2), 0.8),\n        manus.MoveTo((t[0], t[1], 70.0), (0.0, 0.0, angle2), 0.8),\n        manus.MoveTo((t[0], t[1], 70.0), (0.0, 0.0, angle2), 0.0),\n        manus.MoveTo((t[0], t[1], 120.0), (0.0, 0.0, angle2), 0.0)\n    ]\n\n    if workspace.manipulator.trajectory(trajectory):\n        print \"success.\"\n    else:\n        print \"cannot reach.\"\n\n    return True\n\ngroups = {\n    \"red\": {\"region\" : [120, -100, 120, 80], \"color\": [255, 255, 0]},\n    \"blue\": {\"region\" : [120, 20, 120, 80], \"color\": [0, 255, 255]}\n}\n\ntry:\n\n    while True:\n        workspace.wait(1000)\n\n        blocks = workspace.detect_blocks()\n        shuffle(blocks)\n\n        print \"Detected %d blocks\" % len(blocks)\n\n        for i, block in enumerate(blocks):\n            if evaluate_block(workspace, blocks, i, groups):\n                break\nexcept KeyboardInterrupt:\n    pass\nexcept Exception:\n    print traceback.format_exc()\n\n","read_only":true}
